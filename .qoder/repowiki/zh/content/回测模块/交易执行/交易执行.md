# 交易执行

<cite>
**本文档中引用的文件**  
- [executor.py](file://qlib/backtest/executor.py)
- [backtest.py](file://qlib/backtest/backtest.py)
- [decision.py](file://qlib/backtest/decision.py)
- [workflow.py](file://examples/nested_decision_execution/workflow.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心执行器类分析](#核心执行器类分析)
3. [回测循环机制](#回测循环机制)
4. [订单执行流程](#订单执行流程)
5. [交易日历管理](#交易日历管理)
6. [多层级执行机制](#多层级执行机制)
7. [执行器配置示例](#执行器配置示例)
8. [策略模块交互](#策略模块交互)
9. [常见问题与解决方案](#常见问题与解决方案)
10. [并行与串行交易模式](#并行与串行交易模式)

## 引言
Qlib框架提供了一套完整的交易执行机制，支持从简单到复杂的多种回测场景。该机制的核心是执行器（Executor）系统，它负责将策略生成的交易决策转化为实际的交易行为。本文档深入分析Qlib的交易执行架构，重点介绍BaseExecutor、NestedExecutor和SimulatorExecutor三个核心类的实现细节及其相互关系。

## 核心执行器类分析

### BaseExecutor类
BaseExecutor是所有执行器的基类，定义了执行器的基本接口和通用功能。它负责管理交易日历、账户状态和执行流程控制。

```mermaid
classDiagram
class BaseExecutor {
+string time_per_step
+dict indicator_config
+bool generate_portfolio_metrics
+bool verbose
+bool track_data
+Exchange trade_exchange
+CommonInfrastructure common_infra
+string settle_type
+__init__(time_per_step, start_time, end_time, indicator_config, generate_portfolio_metrics, verbose, track_data, trade_exchange, common_infra, settle_type)
+reset_common_infra(common_infra, copy_trade_account)
+trade_exchange() Exchange
+trade_calendar() TradeCalendarManager
+reset(common_infra, **kwargs)
+get_level_infra() LevelInfrastructure
+finished() bool
+execute(trade_decision, level) List[object]
+_collect_data(trade_decision, level) Union[Generator, Tuple[List[object], dict]]
+collect_data(trade_decision, return_value, level) Generator[Any, Any, List[object]]
+get_all_executors() List[BaseExecutor]
}
```

**图示来源**  
- [executor.py](file://qlib/backtest/executor.py#L21-L306)

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L21-L306)

### NestedExecutor类
NestedExecutor实现了嵌套执行机制，允许在每个交易周期内进行更高频率的交易决策和执行。它包含一个内部执行器和内部策略，形成多层级的执行架构。

```mermaid
classDiagram
class NestedExecutor {
+BaseExecutor inner_executor
+BaseStrategy inner_strategy
+bool _skip_empty_decision
+bool _align_range_limit
+__init__(time_per_step, inner_executor, inner_strategy, start_time, end_time, indicator_config, generate_portfolio_metrics, verbose, track_data, skip_empty_decision, align_range_limit, common_infra)
+reset_common_infra(common_infra, copy_trade_account)
+_init_sub_trading(trade_decision)
+_update_trade_decision(trade_decision) BaseTradeDecision
+_collect_data(trade_decision, level) Generator[Any, Any, Tuple[List[object], dict]]
+post_inner_exe_step(inner_exe_res)
+get_all_executors() List[BaseExecutor]
}
BaseExecutor <|-- NestedExecutor
```

**图示来源**  
- [executor.py](file://qlib/backtest/executor.py#L309-L497)

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L309-L497)

### SimulatorExecutor类
SimulatorExecutor模拟真实市场环境下的交易执行，支持串行和并行两种交易模式。它直接与交易所交互，执行具体的买卖订单。

```mermaid
classDiagram
class SimulatorExecutor {
+string TT_SERIAL
+string TT_PARAL
+string trade_type
+__init__(time_per_step, start_time, end_time, indicator_config, generate_portfolio_metrics, verbose, track_data, common_infra, trade_type)
+_get_order_iterator(trade_decision) List[Order]
+_collect_data(trade_decision, level) Tuple[List[object], dict]
}
BaseExecutor <|-- SimulatorExecutor
```

**图示来源**  
- [executor.py](file://qlib/backtest/executor.py#L512-L627)

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L512-L627)

## 回测循环机制
collect_data_loop函数是Qlib回测系统的核心协调器，它负责协调策略和执行器之间的交互，驱动整个回测循环的进行。

```mermaid
flowchart TD
Start([开始回测循环]) --> ResetExecutor["重置执行器 (trade_executor.reset)"]
ResetExecutor --> ResetStrategy["重置策略 (trade_strategy.reset)"]
ResetStrategy --> InitProgressBar["初始化进度条"]
InitProgressBar --> CheckFinished{"执行器已完成?"}
CheckFinished --> |否| GenerateDecision["生成交易决策 (trade_strategy.generate_trade_decision)"]
GenerateDecision --> ExecuteDecision["执行决策 (trade_executor.collect_data)"]
ExecuteDecision --> PostStep["策略后处理 (trade_strategy.post_exe_step)"]
PostStep --> UpdateProgress["更新进度条"]
UpdateProgress --> CheckFinished
CheckFinished --> |是| Finalize["完成回测"]
Finalize --> CollectMetrics["收集所有执行器的指标"]
CollectMetrics --> ReturnResults["返回投资组合和指标数据"]
ReturnResults --> End([结束])
```

**图示来源**  
- [backtest.py](file://qlib/backtest/backtest.py#L52-L109)

**本节来源**  
- [backtest.py](file://qlib/backtest/backtest.py#L52-L109)

## 订单执行流程
订单执行流程从策略生成交易决策开始，经过执行器处理，最终在交易所完成实际交易。

```mermaid
sequenceDiagram
participant Strategy as 策略模块
participant Executor as 执行器
participant Exchange as 交易所
Strategy->>Executor : generate_trade_decision()
Executor->>Executor : collect_data()
Executor->>Executor : _collect_data()
Executor->>Executor : _get_order_iterator()
loop 每个订单
Executor->>Exchange : deal_order(order, trade_account, dealt_order_amount)
Exchange-->>Executor : trade_val, trade_cost, trade_price
Executor->>Executor : 更新执行结果
Executor->>Executor : 更新已交易金额
alt verbose模式
Executor->>Console : 打印交易信息
end
end
Executor-->>Strategy : 返回执行结果
```

**图示来源**  
- [executor.py](file://qlib/backtest/executor.py#L512-L627)
- [decision.py](file://qlib/backtest/decision.py#L36-L150)

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L512-L627)
- [decision.py](file://qlib/backtest/decision.py#L36-L150)

## 交易日历管理
交易日历管理通过TradeCalendarManager类实现，负责跟踪当前交易时间、步进到下一个交易周期以及判断回测是否完成。

```mermaid
classDiagram
class TradeCalendarManager {
+get_step_time() Tuple[Timestamp, Timestamp]
+get_trade_step() int
+get_trade_len() int
+step()
+finished() bool
+reset(start_time, end_time, freq)
}
class BaseExecutor {
+trade_calendar() TradeCalendarManager
}
BaseExecutor --> TradeCalendarManager : "使用"
```

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L150-L160)

## 多层级执行机制
Qlib的多层级执行机制允许构建复杂的嵌套执行架构，支持不同时间频率的混合回测。

```mermaid
graph TD
TopExecutor[日级执行器<br>time_per_step='day'] --> MidExecutor[30分钟级执行器<br>time_per_step='30min']
MidExecutor --> BottomExecutor[5分钟级执行器<br>time_per_step='5min']
TopStrategy[日级策略] --> TopExecutor
MidStrategy[30分钟级策略] --> MidExecutor
BottomStrategy[5分钟级策略] --> BottomExecutor
TopExecutor --> |包含| MidExecutor
MidExecutor --> |包含| BottomExecutor
class TopExecutor,NestedExecutor
class MidExecutor,NestedExecutor
class BottomExecutor,SimulatorExecutor
```

**图示来源**  
- [workflow.py](file://examples/nested_decision_execution/workflow.py#L60-L100)

**本节来源**  
- [workflow.py](file://examples/nested_decision_execution/workflow.py#L60-L100)

## 执行器配置示例
以下示例展示了如何配置不同类型的执行器，包括嵌套执行器和模拟执行器的组合。

```mermaid
erDiagram
EXECUTOR ||--o{ INNER_EXECUTOR : "包含"
EXECUTOR ||--o{ INNER_STRATEGY : "使用"
INNER_EXECUTOR ||--o{ INNER_EXECUTOR2 : "包含"
INNER_EXECUTOR ||--o{ INNER_STRATEGY2 : "使用"
INNER_EXECUTOR2 ||--o{ INNER_STRATEGY3 : "使用"
EXECUTOR {
string class "NestedExecutor"
string time_per_step "day"
}
INNER_EXECUTOR {
string class "NestedExecutor"
string time_per_step "30min"
}
INNER_EXECUTOR2 {
string class "SimulatorExecutor"
string time_per_step "5min"
string trade_type "serial"
}
INNER_STRATEGY {
string class "SBBStrategyEMA"
string freq "1min"
}
INNER_STRATEGY2 {
string class "TWAPStrategy"
}
```

**图示来源**  
- [workflow.py](file://examples/nested_decision_execution/workflow.py#L60-L100)

**本节来源**  
- [workflow.py](file://examples/nested_decision_execution/workflow.py#L60-L100)

## 策略模块交互
执行器与策略模块通过标准化的接口进行交互，确保了系统的灵活性和可扩展性。

```mermaid
classDiagram
class BaseStrategy {
+generate_trade_decision(execute_result) BaseTradeDecision
+reset(level_infra)
+post_exe_step(execute_result)
+post_upper_level_exe_step()
+update_trade_decision(trade_decision, trade_calendar) Optional[BaseTradeDecision]
+alter_outer_trade_decision(trade_decision) BaseTradeDecision
}
class BaseExecutor {
+collect_data(trade_decision, return_value, level) Generator[Any, Any, List[object]]
+_collect_data(trade_decision, level) Union[Generator, Tuple[List[object], dict]]
}
BaseExecutor --> BaseStrategy : "调用"
BaseStrategy --> BaseExecutor : "提供决策"
```

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L309-L497)
- [backtest.py](file://qlib/backtest/backtest.py#L52-L109)

## 常见问题与解决方案

### 空决策处理
当策略生成空决策时，系统提供了灵活的处理机制。

```mermaid
flowchart TD
StartDecision{决策为空?} --> |是| CheckSkip{"skip_empty_decision<br>为真?"}
CheckSkip --> |是| BreakLoop["跳出内层循环"]
CheckSkip --> |否| ContinueProcessing["继续处理"]
StartDecision --> |否| ProcessOrders["处理订单"]
ProcessOrders --> CheckRange{"在range_limit内?"}
CheckRange --> |是| ExecuteOrders["执行订单"]
CheckRange --> |否| StepForward["日历步进"]
```

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L380-L390)

## 并行与串行交易模式
SimulatorExecutor支持两种交易模式，各有其适用场景和性能特点。

```mermaid
graph TB
subgraph 串行模式
direction LR
SellOrder[卖出订单] --> BuyOrder[买入订单]
BuyOrder --> UpdateAccount["更新账户<br>(使用卖出所得资金)"]
end
subgraph 并行模式
direction LR
SellOrder2[卖出订单] --> |同时| BuyOrder2[买入订单]
BuyOrder2 --> CheckFunds{"资金足够?}
CheckFunds --> |否| Failure["交易失败"]
CheckFunds --> |是| UpdateAccount2["更新账户"]
end
TradeType[交易类型] --> |trade_type='serial'| 串行模式
TradeType --> |trade_type='parallel'| 并行模式
```

**本节来源**  
- [executor.py](file://qlib/backtest/executor.py#L512-L627)